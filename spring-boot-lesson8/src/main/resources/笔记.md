## 实体（Entities）

轻量级持久化域（Domain）对象。

实体类（Entity Class）

## 实体类（Entity Class）

实体类可能利用辅助类或者用于表示状态。

### 约束

*   实体类必须使用@Entity标注或者XML描述

*   实体类至少包含一个默认构造器，并且构造器必须是public 或者 protected

*   实体类必须是顶级类，不能是枚举或者接口

*   实体类禁止是final类,它的所有方法都不允许是 final 的

*   实体支持继承、多态关联以及多态查询

### 为什么String类是final

1.  **安全性**：系统可以分发敏感的只读信息，而不必担心它们会被改变
2.  **性能**：不可变数据在使线程安全的过程中非常有用。



### 实体持久字段和属性  

  实体持久状态由字段（Fields）或者属性（Properties），字段即实例的属性或变量，属性则是JavaBeans实例的setter或getter方法。

  实例属性的访问性必须是private、protected或者包可见，属性的可见性必须是public或者protected。

  字段和属性可能是单一类型值或集合类型值。

### 持久字段和属性类型

*   原生类型

*   Java Serializable类型

*   自定义类型（实现Serializable接口）

*   枚举

*   实体类型（包括集合实体类型）

*   嵌入类型

### 字段和属性访问类型（Access Type）

#### 默认访问类型

*   非transient 或者@Transient字段

*   非@Transient 属性

#### 显示访问类型

*   注解类型
    *   实体类
    *   映射超类
    *   嵌套类

*   注解
    *   @Access(AccessType.FIELD) 字段

    *   @Access(AccessType.PROPERTY) 属性

### 实体主键（Primary Key）

  每个实体必须存在主键，主键必须定义在实体类。

#### 简单主键

*   @Id

#### 复合主键

 一个组合主键必须对应于一个单一持久化字段或属性，或者对应于一组持久
化字段或属性。即必须定义一个主键类来代表组合主键。组合主键通常在这种情况下发生：当映射逻辑数据库时，数据库的主键是由几列组合而成的。使用EmbeddedId和IdClass注解表示复合主键。

*   @EmbeddedId
*   @IdClass

#### 规则：

* 主键类必须是 public 的，并且有一个 public 的无参数构造器。 
* 如果使用基于属性的访问，则主键类的属性必须是public的或protected的。 
* 主键类必须是可序列化的
* 注解类必须定义equals和hashCode方法。这些方法的值相等的语义必须与数据中的主键相等语义一致
* 复合主键必须表示并映射为可嵌入类，或者必须表示并映射到实体类的多个字段或属性
* 如果主键类映射到实体类的多个字段或者属性上，主键类的字段或属性，必须和实体类的字段或属性具有相同的名称和类型

应用程序不能修改主键的值。这包括不更改作为主键的复合类型的值或复合主键的元素。
实现可能（但不是必需）抛出异常。 便携式应用程序不得依赖任何此类特定的
行为。



### 实体关系

  实体关系可能一对一、一对多、多对一或多对多，这些关系是多态性的，可以是单向或者双向。

#### 注解表述方式

*   @OneToOne

*   @OneToMany

*   @ManyToOne

*   @ManyToMany

#### XML表述方式

*   @EmbeddedId

*   @IdClass

### 实体双向关系

  实体双向关系是指两实体之间不仅存在拥有方（owning），也存在倒转方（inverse）。主方决定了更新级联关系到数据库。

#### 规则

*   倒转必须通过@OneToOne、@OneToMany或者@ManyToMany中的mappedBy属性方法关联到拥有方的字段或者属性。

*   一对多、多对一双向关系中的多方必须是主方，因此@ManyToOne 注解不能指定mappedBy属性方法。

*   双向一对一关系中，主方相当于包含外键的一方。

*   双向多对多关系中，任何一方可能是拥有方。



    

